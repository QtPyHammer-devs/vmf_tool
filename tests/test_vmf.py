import os

import pytest

import vmf_tool


# TODO: test handling of malformed .vmfs
# -- 0 bytes files, incomplete files, invalid keyvalues etc.
# NOTE: ValveVMF also tests for this, but as a wrapper we should think about how we handle those errors

test_map_dir = "tests/mapsrc"
test_maps = [os.path.join(test_map_dir, f"{m}.vmf") for m in ("blank", "test", "test2")]
# blank: no objects, the default generated by hammer
# test: a 64x64x64 nodraw cube
# test2: various objects & entity logic


@pytest.mark.parametrize("filename", test_maps)
def test_load_from_file(filename):
    vmf = vmf_tool.Vmf.from_file(filename)
    # assert len(vmf.import_errors) == 0
    # TODO: re-implement import_errors to allow for partial loads
    # -- scrapping invalid brushes etc. like regular hammer
    del vmf


# TODO: verify Brush planes (vec3, float) align with Vmf planes (vec3, vec3, vec3)
@pytest.mark.parametrize("filename", test_maps)
def test_load_quality(filename):
    vmf = vmf_tool.Vmf.from_file(filename)
    for brush in vmf.brushes.values():
        for face in brush:
            _source_plane = dict(face._source.properties)["plane"]
            _source_tri = [vmf_tool.vector.vec3(*P) for P in _source_plane]
            normal, distance = face.plane
            assert all([vmf_tool.vector.dot(P, normal) == distance for P in _source_tri]), (brush.id, face.id)


@pytest.mark.parametrize("filename", ("blank", "test", "test2"))
def test_save_quality(filename):
    map_dir = "tests/mapsrc"
    original_filename = os.path.join(map_dir, f"{filename}.vmf")
    saved_filename = os.path.join(map_dir, f"{filename}_resaved.vmf")
    vmf_tool.Vmf.from_file(original_filename).save_as(saved_filename)
    # recollect both .vmfs post-save
    # TODO: confirm original_vmf was not altered
    original_vmf = vmf_tool.Vmf.from_file(original_filename)
    saved_vmf = vmf_tool.Vmf.from_file(saved_filename)

    # assert len(saved_vmf.import_errors) == len(original_vmf.import_errors)
    assert len(saved_vmf.brushes) == len(original_vmf.brushes)
    for saved_brush, original_brush in zip(saved_vmf.brushes.values(), original_vmf.brushes.values()):
        assert saved_brush.id == original_brush.id
        for saved_face, original_face in zip(saved_brush, original_brush):
            # TODO: determine a margin of error for comparing brushes
            assert saved_face.plane == original_face.plane
    assert len(saved_vmf.entities) == len(original_vmf.entities)
    os.remove(saved_filename)  # delete saved file only if all tests succeed
    # NOTE: use `diff -u -w src.vmf dest.vmf` on linux to compare files
    saved_filename_vmx = saved_filename[:-1] + "x"
    if os.path.exists(saved_filename_vmx):
        os.remove(saved_filename_vmx)


def test_generate_blank():
    vmf_tool.Vmf("tests/mapsrc/untitled.vmf").save()
    if os.path.exists("tests/mapsrc/untitled.vmx"):
        os.remove("tests/mapsrc/untitled.vmx")


def test_connections():  # ISSUE #13  (Unwanted removal of duplicate keys...)
    test2_vmf = vmf_tool.Vmf.from_file("tests/mapsrc/test2.vmf")
    cp1 = [e for e in test2_vmf.entities.values() if dict(e.properties).get("targetname", None) == "cp1"][0]
    # ^ need a more convenient way of accessing entities by name
    cp1_connections = {n.name: n for n in cp1.nodes}["connections"].properties
    assert len([k for k, v in cp1_connections if k == "OnCapTeam1"]) == 2
    assert len([k for k, v in cp1_connections if k == "OnCapTeam2"]) == 2
